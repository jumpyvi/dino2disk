# window.py
#
# Copyright 2024 mirkobrombin
# Copyright 2024 muqtadir
#
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundationat version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import json
import logging
import os
import subprocess

from gi.repository import Adw, Gtk

from dako_installer.utils.builder import Builder
from dako_installer.utils.processor import Processor
from dako_installer.views.confirm import VanillaConfirm
from dako_installer.views.done import VanillaDone
from dako_installer.views.progress import VanillaProgress

logger = logging.getLogger("Installer::Window")


@Gtk.Template(resource_path="/org/projectbluefin/dakoinstaller/gtk/window.ui")
class VanillaWindow(Adw.ApplicationWindow):
    __gtype_name__ = "VanillaWindow"

    carousel = Gtk.Template.Child()
    carousel_indicator_dots = Gtk.Template.Child()
    btn_back = Gtk.Template.Child()
    btn_about = Gtk.Template.Child()
    toasts = Gtk.Template.Child()

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # this starts the builder and generates the widgets
        # to put in the carousel
        self.__builder = Builder(self)

        # system views
        self.__view_confirm = VanillaConfirm(self)
        self.__view_progress = VanillaProgress(self, self.recipe.get("tour", {}))
        self.__view_done = VanillaDone(self)

        # this builds the UI with the widgets generated by the builder
        self.__build_ui()

        # connect system signals
        self.__connect_signals()

        # some variables to track state
        self.install_mode = 0

    def __connect_signals(self):
        self.btn_back.connect("clicked", self.back)
        self.btn_about.connect("clicked", self.show_about)
        self.carousel.connect("page-changed", self.__on_page_changed)
        self.__builder.widgets[-1][0].btn_next.connect("clicked", self.update_finals)
        self.__view_confirm.connect("installation-confirmed", self.on_installation_confirmed)

    def rebuild_ui(self, mode=1):
        if self.install_mode == mode:
            return
        self.install_mode = mode
        self.__build_ui(True, mode)

    def __build_ui(self, rebuild=False, mode=0):
        property_list = self.__builder.property_list

        if rebuild:
            self.carousel.remove(self.__view_confirm)
            self.carousel.remove(self.__view_progress)
            self.carousel.remove(self.__view_done)

        if "VANILLA_FORCE_TOUR" not in os.environ:
            for i, (widget, step_props) in enumerate(self.__builder.widgets):
                if rebuild:
                    if "protected" in step_props:
                        continue
                    else:
                        if widget.get_parent() == self.carousel:
                            self.carousel.remove(widget)
                if "custom_image" in step_props and mode == 0:
                    continue
                if "default_image" in step_props and mode == 1:
                    continue
                
                if widget.get_parent() != self.carousel:
                    logger.info("(%s) Adding widget to carousel", widget.__gtype_name__)
                    self.carousel.append(widget)
        else:
            self.__on_page_changed()

        self.carousel.append(self.__view_confirm)
        self.carousel.append(self.__view_progress)
        self.carousel.append(self.__view_done)

    def __on_page_changed(self, carousel, index, *args):
        page = self.carousel.get_nth_page(index)

        logger.info("(%s) Page is changing to index %d", page.__gtype_name__, index)

        if page not in [self.__view_progress, self.__view_done]:
            logger.info("(%s) It is not a final page", page.__gtype_name__)
            self.btn_back.set_visible(index != 0)
            self.btn_back.set_sensitive(index != 0)
            self.carousel_indicator_dots.set_visible(index != 0)
            return

        logger.info("(%s) It is a final page", page.__gtype_name__)

        self.btn_back.set_visible(False)
        self.btn_back.set_sensitive(False)
        self.carousel_indicator_dots.set_visible(False)

        # keep the btn_back button locked if this is the last page
        if page == self.__view_done:
            logger.info("(%s) It is the DONE page", page.__gtype_name__)
            return

    def update_finals(self, *args):
        # collect all the finals
        if "VANILLA_FORCE_TOUR" not in os.environ:
            self.finals = self.__builder.get_finals()
        else:
            self.finals = json.loads(os.environ["VANILLA_FORCE_TOUR"])

        self.__view_confirm.update(self.finals)

    def on_installation_confirmed(self, *args):
        # Set callback to move to next page when disk operations complete
        Processor.set_completion_callback(self.__go_to_done_page)
        
        recipe = Processor.gen_install_recipe(
            self.recipe.get("log_file", "/tmp/dako.log"),
            self.finals,
            self.recipe,
        )
        self.__view_progress.start(recipe)
        self.next()

    def __go_to_done_page(self, *args):
        self.carousel.scroll_to(self.__view_done, True)

    def next(self, widget=None, fn=None, *args):
        logger.info("Going to next page")

        cur_pos = self.carousel.get_position()
        cur_index = int(round(cur_pos))
        n_pages = self.carousel.get_n_pages()
        
        logger.info(f"Current position: {cur_pos}, index: {cur_index}, total pages: {n_pages}")

        if cur_index >= n_pages:
            logger.warning("Already at the last page or index out of bounds")
            return

        page = self.carousel.get_nth_page(cur_index)
        if page.delta:
            logger.info(f"Removing deltas of page {cur_index}")
            page.del_deltas()
        
        next_index = cur_index + 1
        if next_index >= n_pages:
            logger.warning("No next page to scroll to")
            return

        logger.info(f"Next page is {next_index}")

        if fn is not None:
            logger.info("Executing page's custom function")
            fn()
            logger.info("Finished executing page's custom function")

        next_page = self.carousel.get_nth_page(next_index)
        self.carousel.scroll_to(next_page, True)
        if next_page.delta:
            logger.info(f"Generating deltas of page {next_index}")
            next_page.gen_deltas()

    def back(self, *args):
        logger.info("Going to previous page")

        cur_pos = self.carousel.get_position()
        cur_index = int(round(cur_pos))
        
        logger.info(f"Current position: {cur_pos}, index: {cur_index}")

        if cur_index <= 0:
            logger.warning("Already at the first page")
            return

        page = self.carousel.get_nth_page(cur_index)
        if page.delta:
            page.del_deltas()
        
        prev_index = cur_index - 1
        logger.info(f"Previous page is {prev_index}")

        prev_page = self.carousel.get_nth_page(prev_index)
        self.carousel.scroll_to(prev_page, True)
        if prev_page.delta:
            prev_page.gen_deltas()

    def toast(self, message, timeout=3):
        toast = Adw.Toast.new(message)
        toast.props.timeout = timeout
        self.toasts.add_toast(toast)

    def show_about(self, *args):
        """About dialog."""
        about = Adw.AboutWindow(transient_for=self)
        about.set_application_name("Dakota Installer")
        about.set_version(f"Commit version: {self._git_ref()}")
        about.set_developer_name("Project Bluefin")
        about.set_website("https://projectbluefin.io/")
        about.add_credit_section("Contributors", [
            "The Bluefin team and community",
            "jumpyvi",
        ])
        about.add_credit_section("Artists", [
            "Delphic Melody",
            "Quince",
        ])
        about.add_acknowledgement_section(
            ("Installer forked from:"),
            [
                "The VanillaOS project https://github.com/Vanilla-OS",
            ],
        )
        about.add_acknowledgement_section(
            ("Possible with:"),
            [
                "The GnomeOS project https://os.gnome.org/",
                "The BootC project  https://bootc-dev.github.io/"
            ],
        )
        about.set_issue_url("https://github.com/projectbluefin/dakota/issues")

        about.present()

    def _git_ref(self) -> str:
        """Return a version string for the installer.
        """
        try:
            ref = subprocess.check_output(
                ["git", "rev-parse", "--short", "HEAD"],
                cwd=".",
                stderr=subprocess.DEVNULL,
            )
            return ref.decode().strip()
        except Exception as e:
            print(f"DEBUG: Git command failed due to: {e}")
            if hasattr(e, 'stderr') and e.stderr:
                print(f"Git error output: {e.stderr.decode()}")
            return "unversioned"

    def set_installation_result(self, result):
        self.__view_done.set_result(result)
